name: CD Deploy to Droplet

# Se activa cuando hay un push a la rama 'develop'
# Cambia 'develop' a 'main' o la rama que uses para desplegar
on:
  push:
    branches:
      - develop
      - feature/*

jobs:
  deploy:
    name: Deploy Application to DigitalOcean Droplet
    runs-on: ubuntu-latest # El tipo de m√°quina virtual que usar√° GitHub Actions para ejecutar el job

    steps:
      # Paso 1: No necesitamos hacer checkout del c√≥digo en el runner de GitHub Actions
      # porque todos los comandos se ejecutar√°n remotamente en el Droplet.

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0 # Acci√≥n para configurar el agente SSH
        with:
          ssh-private-key: ${{ secrets.DROPLET_SSH_PRIVATE_KEY }} # Usa la clave privada del secret

      - name: Deploy to Droplet via SSH
        run: |
          echo "Connecting to Droplet: ${{ secrets.DROPLET_IP }}"
          # El comando SSH. -o StrictHostKeyChecking=no es para evitar el prompt de confirmaci√≥n del host la primera vez.
          # Considera a√±adir la huella del host a los known_hosts del runner para mayor seguridad en producci√≥n.
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.DROPLET_SSH_PORT || 22 }} \
            ${{ secrets.DROPLET_SSH_USER }}@${{ secrets.DROPLET_IP }} << 'EOF'

            echo ">>> Navigating to project directory: ${{ secrets.PROJECT_PATH_ON_DROPLET }}"
            cd ${{ secrets.PROJECT_PATH_ON_DROPLET }} || { echo "Failed to cd into project directory"; exit 1; }

            echo ">>> Ensuring current branch is correct (develop) and pulling latest changes..."
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            if [ "$CURRENT_BRANCH" != "develop" ]; then
              echo "Warning: Not on develop branch, currently on $CURRENT_BRANCH. Attempting to switch."
              git checkout develop || { echo "Failed to checkout develop branch"; exit 1; }
            fi
            git pull origin develop || { echo "Failed to pull changes"; exit 1; }

            echo ">>> Updating and restarting Docker services..."
            # Paso 1: Descargar im√°genes base actualizadas (opcional si usas tags fijos)
            docker compose pull || echo "Docker compose pull failed, continuing..."

            # Paso 2: Reconstruir la imagen de la API y levantar todos los servicios
            # --build: Reconstruye servicios con una secci√≥n 'build' si su contexto cambi√≥ (tu API)
            # --force-recreate: Asegura que los contenedores se recreen, √∫til para cambios de config o imagen
            # --remove-orphans: Limpia contenedores de servicios que ya no existen en el docker-compose.yaml
            docker compose up -d --build --force-recreate --remove-orphans || { echo "Docker compose up failed"; exit 1; }

            echo ">>> (Optional) Pruning unused Docker resources..."
            # Descomenta las siguientes l√≠neas si quieres una limpieza m√°s profunda
            # echo "Pruning unused Docker images..."
            # docker image prune -af || echo "Image prune failed, continuing..."
            # echo "Pruning Docker build cache..."
            # docker builder prune -af || echo "Builder prune failed, continuing..."

            echo ">>> Deployment to Droplet finished successfully!"
          EOF

  notify-github:
    name: Smart GitHub Issue Management - CD Failures
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result == 'failure'
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Compute deployment status
        id: compute_status
        run: |
          echo "status=‚ùå FAILED" >> "$GITHUB_OUTPUT"

      - name: Search for existing CD deployment issues
        id: search_issues
        run: |
          SEARCH_QUERY="repo:${{ github.repository }} is:issue is:open label:cd-deployment label:${{ github.ref_name }} label:${{ github.workflow }}"

          echo "Searching for existing issues with query: $SEARCH_QUERY"

          RESPONSE=$(curl -s -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/search/issues?q=$(echo "$SEARCH_QUERY" | sed 's/ /%20/g')")

          ISSUE_COUNT=$(echo "$RESPONSE" | jq -r '.total_count // 0')
          echo "Found $ISSUE_COUNT existing issues"

          if [ "$ISSUE_COUNT" -gt 0 ]; then
            ISSUE_NUMBER=$(echo "$RESPONSE" | jq -r '.items[0].number')
            ISSUE_URL=$(echo "$RESPONSE" | jq -r '.items[0].html_url')
            echo "existing_issue_number=$ISSUE_NUMBER" >> "$GITHUB_OUTPUT"
            echo "existing_issue_url=$ISSUE_URL" >> "$GITHUB_OUTPUT"
            echo "has_existing_issue=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_existing_issue=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create deployment issue body
        id: render_issue
        shell: bash
        run: |
          export STATUS='${{ steps.compute_status.outputs.status }}'
          export WORKFLOW='${{ github.workflow }}'
          export REF_NAME='${{ github.ref_name }}'
          export EVENT_NAME='${{ github.event_name }}'
          export SHA='${{ github.sha }}'
          export SHORT_SHA='${{ github.sha }}' ; SHORT_SHA=${SHORT_SHA:0:7} ; export SHORT_SHA
          export ACTOR='${{ github.actor }}'
          export RUN_URL='${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          export REPO='${{ github.repository }}'
          export TIMESTAMP="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          export DEPLOY_STATUS='${{ needs.deploy.result }}'
          export DROPLET_IP='${{ secrets.DROPLET_IP }}'

          cat > "issue-body.md" << EOF
          # üö® CD Deployment Failure Alert

          ## üìã Deployment Summary
          **Status:** ${STATUS}  
          **Environment:** Production Droplet  
          **Branch:** \`${REF_NAME}\`  
          **Commit:** [\`${SHORT_SHA}\`](https://github.com/${REPO}/commit/${SHA})  
          **Triggered by:** @${ACTOR}  
          **Time:** ${TIMESTAMP}

          ## üîÑ Deployment Details

          | **Component**        | **Status**           | **Description**                                    |
          | -------------------- | -------------------- | -------------------------------------------------- |
          | **SSH Connection**   | \`${DEPLOY_STATUS}\` | Connection to DigitalOcean Droplet                |
          | **Git Operations**   | \`${DEPLOY_STATUS}\` | Branch checkout and pull from repository          |
          | **Docker Services**  | \`${DEPLOY_STATUS}\` | Container rebuild and service restart              |

          ## üîß Deployment Process Failed At:
          - **Target Server:** \`${DROPLET_IP}\`
          - **Project Path:** \`${{ secrets.PROJECT_PATH_ON_DROPLET }}\`
          - **Branch:** \`${REF_NAME}\`

          ## üìä What This Means:
          - ‚ùå The API deployment to production has failed
          - üîÑ Previous version may still be running
          - üö® Manual intervention required

          ## üîó Quick Actions
          - [View Deployment Run](${RUN_URL})
          - [View Failed Commit](https://github.com/${REPO}/commit/${SHA})
          - [View Branch](https://github.com/${REPO}/tree/${REF_NAME})
          - [SSH to Droplet](ssh://${{ secrets.DROPLET_SSH_USER }}@${DROPLET_IP}:${{ secrets.DROPLET_SSH_PORT || 22 }})

          ## üõ†Ô∏è Troubleshooting Steps:
          1. Check SSH connectivity to the droplet
          2. Verify Docker services are running
          3. Check application logs: \`docker compose logs\`
          4. Verify available disk space and resources
          5. Check network connectivity and firewall rules

          ---
          **Auto-generated by CD Pipeline** | **Workflow:** \`${WORKFLOW}\` | **Run ID:** \`${{ github.run_id }}\`

          _This issue will be automatically closed when the deployment succeeds._
          EOF

      - name: Create comment template for existing issue
        if: steps.search_issues.outputs.has_existing_issue == 'true'
        id: render_comment
        shell: bash
        run: |
          export STATUS='${{ steps.compute_status.outputs.status }}'
          export SHA='${{ github.sha }}'
          export SHORT_SHA='${{ github.sha }}' ; SHORT_SHA=${SHORT_SHA:0:7} ; export SHORT_SHA
          export ACTOR='${{ github.actor }}'
          export RUN_URL='${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          export REPO='${{ github.repository }}'
          export TIMESTAMP="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          export DEPLOY_STATUS='${{ needs.deploy.result }}'

          cat > "comment-body.md" << EOF
          ## üîÑ Deployment Update - ${SHORT_SHA}

          **New Failure Detected:** ${STATUS}  
          **Commit:** [\`${SHORT_SHA}\`](https://github.com/${REPO}/commit/${SHA})  
          **Workflow Run:** [View Details](${RUN_URL})  
          **Triggered by:** @${ACTOR}  
          **Time:** ${TIMESTAMP}

          ### üìä Current Deployment Status

          | **Stage**               | **Status**             | **Description**                           |
          | ----------------------- | ---------------------- | ----------------------------------------- |
          | **Deployment Process** | \`${DEPLOY_STATUS}\`   | Full deployment pipeline to droplet      |

          ### üîó Quick Actions
          - [View Workflow Run](${RUN_URL})
          - [View Commit](https://github.com/${REPO}/commit/${SHA})
          - [Check Droplet Status](https://cloud.digitalocean.com/droplets)

          ---
          _This comment was automatically generated by the CD deployment pipeline. Issue will be automatically closed when deployment succeeds._
          EOF

      - name: Comment on existing issue
        if: steps.search_issues.outputs.has_existing_issue == 'true'
        run: |
          COMMENT_BODY=$(cat comment-body.md | jq -Rs .)
          curl -X POST \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "${{ github.api_url }}/repos/${{ github.repository }}/issues/${{ steps.search_issues.outputs.existing_issue_number }}/comments" \
            -d "{\"body\": $COMMENT_BODY}"

          echo "‚úÖ Added comment to existing issue #${{ steps.search_issues.outputs.existing_issue_number }}"
          echo "üîó Issue URL: ${{ steps.search_issues.outputs.existing_issue_url }}"

      - name: Create new issue
        if: steps.search_issues.outputs.has_existing_issue == 'false'
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: |
            CD Deployment ${{ steps.compute_status.outputs.status }} - ${{ github.workflow }} on ${{ github.ref_name }}
          content-filepath: issue-body.md
          assignees: ${{ github.actor }}
          labels: |
            cd-deployment,
            production,
            aca-fail2ban-dashboard,
            ${{ github.ref_name }},
            ${{ github.event_name }},
            ${{ github.workflow }}

  # Segundo job: cierra issues cuando el deployment es exitoso
  close-resolved-issues:
    name: Close Resolved Deployment Issues
    needs: [deploy, notify-github]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result == 'success'
    permissions:
      issues: write
      contents: read
    steps:
      - name: Search and close resolved CD deployment issues
        run: |
          SEARCH_QUERY="repo:${{ github.repository }} is:issue is:open label:cd-deployment label:${{ github.ref_name }} label:${{ github.workflow }}"

          echo "Searching for resolved issues with query: $SEARCH_QUERY"

          RESPONSE=$(curl -s -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/search/issues?q=$(echo "$SEARCH_QUERY" | sed 's/ /%20/g')")

          ISSUE_COUNT=$(echo "$RESPONSE" | jq -r '.total_count // 0')
          echo "Found $ISSUE_COUNT issues to potentially close"

          if [ "$ISSUE_COUNT" -gt 0 ]; then
            echo "$RESPONSE" | jq -r '.items[].number' | while read -r ISSUE_NUMBER; do
              echo "Closing issue #$ISSUE_NUMBER as deployment is now successful"
              
              # Add success comment
              COMMENT_BODY="## ‚úÖ Deployment Resolved!\n\n**Status:** Deployment successful  \n**Commit:** [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})  \n**Workflow Run:** [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})  \n**Resolved by:** @${{ github.actor }}  \n**Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')\n\nClosing this issue as the CD deployment is now successful. üöÄ\n\n---\n_This comment was automatically generated by the CD deployment pipeline._"
              
              curl -X POST \
                -H "Authorization: Bearer ${{ github.token }}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "${{ github.api_url }}/repos/${{ github.repository }}/issues/$ISSUE_NUMBER/comments" \
                -d "{\"body\": \"$COMMENT_BODY\"}"
              
              # Close the issue
              curl -X PATCH \
                -H "Authorization: Bearer ${{ github.token }}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "${{ github.api_url }}/repos/${{ github.repository }}/issues/$ISSUE_NUMBER" \
                -d '{"state": "closed", "state_reason": "completed"}'
              
              echo "‚úÖ Closed issue #$ISSUE_NUMBER"
            done
          else
            echo "No issues found to close"
          fi
